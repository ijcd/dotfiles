#!/bin/bash
# pg - Manage nix-darwin PostgreSQL service
#
# Usage: pg <command> [args]
#
# Commands:
#   start      Start PostgreSQL (shows logs until ready)
#   stop       Stop PostgreSQL (shows logs until stopped)
#   restart    Restart PostgreSQL
#   status     Check if PostgreSQL is running
#   log        Tail the PostgreSQL log
#   log <db>   Tail log filtered by database name
#
# Examples:
#   pg start
#   pg log myapp_dev

set -e

# Configuration
SERVICE_LABEL="org.nixos.postgresql"
DATA_DIR="$HOME/.local/share/postgres"
LOG_DIR="$DATA_DIR/logs"
LOG_FILE="$LOG_DIR/postgresql-$(date +%Y-%m-%d).log"
START_TIMEOUT=30
STOP_TIMEOUT=10

# Colors (if terminal supports it)
if [ -t 1 ]; then
  GREEN='\033[0;32m'
  RED='\033[0;31m'
  YELLOW='\033[0;33m'
  NC='\033[0m'
else
  GREEN='' RED='' YELLOW='' NC=''
fi

#-----------------------------------------------------------
# Helpers
#-----------------------------------------------------------

is_running() {
  # Check via socket (auth-independent, handles stale socket)
  pg_isready -h "$DATA_DIR" -q 2>/dev/null
}

not_running() { ! is_running; }

log_exists() { [ -f "$LOG_FILE" ]; }

# Get current log size in bytes
log_size() {
  log_exists && wc -c < "$LOG_FILE" || echo 0
}

# Print new log content since given byte offset
print_new_logs() {
  local since=$1
  local now
  now=$(log_size)
  if [ "$now" -gt "$since" ]; then
    printf "\n"
    tail -c +"$((since + 1))" "$LOG_FILE"
    echo "$now"  # Return new position
  else
    echo "$since"
  fi
}

# Wait for condition with countdown and incremental log output
# Usage: wait_with_logs <condition> <timeout> <action> <success> <failure>
wait_with_logs() {
  local condition=$1
  local timeout=$2
  local action=$3
  local success_msg=$4
  local fail_msg=$5

  local log_pos elapsed=0
  log_pos=$(log_size)

  while [ $elapsed -lt "$timeout" ]; do
    if $condition; then
      printf "\r\033[K${GREEN}✓ %s (%ds)${NC}\n" "$success_msg" "$elapsed"
      return 0
    fi

    printf "\r\033[K⏳ %s... %ds remaining" "$action" "$((timeout - elapsed))"
    log_pos=$(print_new_logs "$log_pos")

    sleep 1
    elapsed=$((elapsed + 1))
  done

  printf "\r\033[K${RED}✗ %s${NC}\n" "$fail_msg"
  return 1
}

# Wait for log file to appear (up to 2.5s)
wait_for_log() {
  local attempts=0
  while [ $attempts -lt 5 ] && ! log_exists; do
    sleep 0.5
    attempts=$((attempts + 1))
  done
}

# Start the launchd service
start_service() {
  launchctl kickstart -k "gui/$(id -u)/$SERVICE_LABEL" 2>/dev/null ||
    launchctl bootstrap "gui/$(id -u)" "$HOME/Library/LaunchAgents/$SERVICE_LABEL.plist" 2>/dev/null
}

# Stop the launchd service (bootout required due to KeepAlive)
stop_service() {
  launchctl bootout "gui/$(id -u)/$SERVICE_LABEL" 2>/dev/null || true
}

#-----------------------------------------------------------
# Commands
#-----------------------------------------------------------

cmd_start() {
  if is_running; then
    echo -e "${YELLOW}PostgreSQL is already running${NC}"
    return 0
  fi

  if ! start_service; then
    echo -e "${RED}Failed to start service. Try: darwin-rebuild switch${NC}"
    return 1
  fi

  wait_for_log
  wait_with_logs is_running "$START_TIMEOUT" \
    "Starting PostgreSQL" \
    "PostgreSQL is ready" \
    "PostgreSQL failed to start within ${START_TIMEOUT}s" || {
      echo "Check logs: pg log"
      return 1
    }
}

cmd_stop() {
  if ! is_running; then
    echo "PostgreSQL is not running"
    return 0
  fi

  stop_service
  wait_with_logs not_running "$STOP_TIMEOUT" \
    "Stopping PostgreSQL" \
    "PostgreSQL stopped" \
    "PostgreSQL failed to stop within ${STOP_TIMEOUT}s"
}

cmd_restart() {
  cmd_stop || return 1
  echo ""
  cmd_start
}

cmd_status() {
  if is_running; then
    echo -e "${GREEN}PostgreSQL is running${NC}"
    pg_isready -h "$DATA_DIR"
  else
    echo -e "${YELLOW}PostgreSQL is not running${NC}"
    return 1
  fi
}

cmd_log() {
  local db_filter=$1

  if ! log_exists; then
    echo "Log file not found: $LOG_FILE" >&2
    return 1
  fi

  if [ -n "$db_filter" ]; then
    echo "Tailing log for database: $db_filter (Ctrl+C to stop)"
    echo ""
    tail -f "$LOG_FILE" | grep --line-buffered "\[$db_filter\]"
  else
    echo "Tailing log (Ctrl+C to stop)"
    echo ""
    tail -f "$LOG_FILE"
  fi
}

cmd_help() {
  sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
}

#-----------------------------------------------------------
# Main
#-----------------------------------------------------------

case "${1:-}" in
  start)   cmd_start ;;
  stop)    cmd_stop ;;
  restart) cmd_restart ;;
  status)  cmd_status ;;
  log)     cmd_log "$2" ;;
  help|-h|--help) cmd_help ;;
  *)
    echo "Usage: pg {start|stop|restart|status|log [db]|help}" >&2
    exit 1
    ;;
esac
